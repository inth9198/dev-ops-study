리눅스(os) 는 커널과 그외로 나뉨

## 커널(Kernel)이란?

커널은 운영체제의 핵심 부분으로, 하드웨어와 소프트웨어 간의 중재자 역할을 합니다.

### 주요 기능:

- **하드웨어 관리**: CPU, 메모리, 디스크, 네트워크 등 하드웨어 리소스를 관리
- **프로세스 관리**: 프로그램 실행, 스케줄링, 멀티태스킹 처리
- **메모리 관리**: 메모리 할당 및 해제, 가상 메모리 관리
- **파일 시스템 관리**: 파일과 디렉토리 접근 제어
- **시스템 호출 제공**: 사용자 프로그램이 하드웨어에 접근할 수 있는 인터페이스 제공
- **보안 및 권한 관리**: 사용자 권한, 접근 제어 관리

### 커널의 위치:

- 하드웨어와 애플리케이션 사이에 위치
- 사용자 공간(User Space)과 커널 공간(Kernel Space)을 분리하여 시스템 안정성 보장

## 시스템 콜(System Call)이란?

시스템 콜은 사용자 공간의 프로그램이 커널 공간의 기능을 사용할 수 있도록 제공되는 인터페이스입니다.

### 주요 특징:

- **권한 전환**: 사용자 모드에서 커널 모드로 전환하여 실행
- **보안**: 직접적인 하드웨어 접근을 차단하고, 커널을 통한 안전한 접근만 허용
- **추상화**: 복잡한 하드웨어 작업을 간단한 함수 호출로 제공

### 주요 시스템 콜 종류:

- **파일 조작**: `open()`, `read()`, `write()`, `close()` - 파일 읽기/쓰기
- **프로세스 관리**: `fork()`, `exec()`, `wait()`, `exit()` - 프로세스 생성 및 관리
- **메모리 관리**: `mmap()`, `munmap()`, `brk()` - 메모리 할당 및 해제
- **네트워크**: `socket()`, `bind()`, `connect()`, `send()`, `recv()` - 네트워크 통신
- **시스템 정보**: `getpid()`, `getuid()`, `time()` - 시스템 정보 조회

### 시스템 콜 동작 과정:

1. 사용자 프로그램이 시스템 콜 함수 호출
2. 라이브러리 함수가 시스템 콜 번호와 인자를 준비
3. CPU가 사용자 모드에서 커널 모드로 전환 (인터럽트 발생)
4. 커널이 해당 시스템 콜을 실행
5. 결과를 반환하고 다시 사용자 모드로 전환
6. 사용자 프로그램이 결과를 받음

### 시스템 콜 래퍼 함수 (System Call Wrapper)

- **개념**: 사용자 프로그램이 시스템 콜을 직접 호출하지 않고, C 라이브러리(예: glibc)가 제공하는 래퍼 함수를 통해 간접적으로 호출하는 방식

- **원리**:

  1. 사용자 프로그램이 `open()`, `read()` 같은 함수를 호출
  2. 이 함수들은 실제로는 C 라이브러리에 정의된 래퍼 함수
  3. 래퍼 함수가 내부적으로:
     - 시스템 콜 번호를 레지스터에 설정
     - 인자를 적절한 레지스터나 스택에 준비
     - CPU 인터럽트나 특수 명령어(`syscall`, `int 0x80`)를 통해 커널 모드로 전환
     - 커널이 시스템 콜을 실행한 후 결과를 받아서 반환
  4. 래퍼 함수가 에러 처리나 반환값 변환 후 사용자에게 반환

- **래퍼 함수가 필요한 이유**:

  1. **추상화**: 복잡한 시스템 콜 인터페이스를 간단한 함수 호출로 제공
  2. **에러 처리**: 시스템 콜의 에러 코드를 표준 errno로 변환
  3. **호환성**: 다양한 아키텍처와 운영체제 버전 간 호환성 보장
  4. **보안**: 입력 검증 및 보안 체크 수행
  5. **편의성**: 여러 시스템 콜을 조합하여 더 높은 수준의 기능 제공

- **래퍼 함수의 동작 과정**:

  ```
  사용자 프로그램
    ↓
  open() 함수 호출 (래퍼 함수)
    ↓
  시스템 콜 번호 준비 (예: SYS_open = 2)
    ↓
  인자를 레지스터에 설정
    ↓
  syscall 명령어 실행 (CPU 모드 전환)
    ↓
  커널에서 실제 open 시스템 콜 실행
    ↓
  결과 반환
    ↓
  래퍼 함수가 errno 설정 및 반환값 처리
    ↓
  사용자 프로그램에 결과 반환
  ```

- **예시**:

```c
// 사용자가 호출하는 함수 (래퍼 함수)
int fd = open("file.txt", O_RDONLY);

// 내부적으로는 다음과 같은 과정이 일어남:
// 1. glibc의 open() 래퍼 함수가 호출됨
// 2. 래퍼 함수가 시스템 콜 번호(SYS_open)를 설정
// 3. 인자("file.txt", O_RDONLY)를 레지스터에 준비
// 4. syscall 명령어로 커널 모드 전환
// 5. 커널이 실제 파일 열기 작업 수행
// 6. 결과를 래퍼 함수에 반환
// 7. 래퍼 함수가 errno 설정 후 fd 반환
```

### 예시:

```c
// 파일 읽기 시스템 콜 사용 예시
int fd = open("file.txt", O_RDONLY);  // open() 래퍼 함수 호출
read(fd, buffer, size);                // read() 래퍼 함수 호출
close(fd);                              // close() 래퍼 함수 호출
```

## CPU 모드: 커널 모드와 사용자 모드

CPU는 실행 중인 코드의 권한 수준에 따라 두 가지 모드로 동작합니다.

### 사용자 모드(User Mode)

- **권한 수준**: 낮음 (Ring 3)
- **실행 주체**: 일반 사용자 프로그램, 애플리케이션
- **제한 사항**:
  - 하드웨어에 직접 접근 불가
  - 특권 명령어(privileged instructions) 실행 불가
  - 메모리 접근 제한 (자신의 메모리 공간만 접근 가능)
  - I/O 장치 직접 제어 불가
- **목적**: 시스템 안정성과 보안 보장

### 커널 모드(Kernel Mode)

- **권한 수준**: 높음 (Ring 0)
- **실행 주체**: 운영체제 커널 코드
- **가능한 작업**:
  - 모든 하드웨어에 직접 접근 가능
  - 특권 명령어 실행 가능
  - 전체 메모리 공간 접근 가능
  - I/O 장치 직접 제어 가능
  - CPU 모드 전환 제어 가능
- **목적**: 시스템 리소스 관리 및 제어

### 모드 전환(Mode Switching)

#### 사용자 모드 → 커널 모드 전환 시점:

1. **시스템 콜 호출**: 사용자 프로그램이 시스템 콜을 호출할 때
2. **인터럽트 발생**: 하드웨어 인터럽트(키보드 입력, 타이머 등) 발생 시
3. **예외(Exception) 발생**: 잘못된 메모리 접근, 0으로 나누기 등 오류 발생 시

#### 커널 모드 → 사용자 모드 전환:

- 커널 작업 완료 후 자동으로 사용자 모드로 복귀
- `iret` (interrupt return) 명령어로 전환

### 모드 전환 과정 예시:

```
[사용자 모드]
  ↓
시스템 콜 호출 (예: read())
  ↓
인터럽트 발생 (INT 0x80 또는 syscall)
  ↓
[커널 모드]
  ↓
커널이 시스템 콜 처리
  ↓
결과 반환
  ↓
[사용자 모드로 복귀]
```

### 왜 두 가지 모드가 필요한가?

1. **보안**: 사용자 프로그램이 시스템을 손상시키는 것을 방지
2. **안정성**: 한 프로그램의 오류가 전체 시스템에 영향을 주지 않도록 격리
3. **자원 보호**: 중요한 시스템 리소스를 보호
4. **멀티태스킹**: 여러 프로그램이 안전하게 동시 실행

### 예시 시나리오:

```c
// 사용자 모드에서 실행
printf("Hello");  // 라이브러리 함수 호출
  ↓
// 내부적으로 write() 시스템 콜 호출
  ↓
// CPU가 커널 모드로 전환
  ↓
// 커널이 실제로 화면에 출력
  ↓
// 사용자 모드로 복귀
```

## 시스템 콜 추적 도구

시스템 콜을 실제로 관찰하고 분석하기 위한 도구들이 있습니다.

### Linux: strace

- **용도**: 프로그램이 호출하는 시스템 콜을 추적
- **사용법**: `strace -o output.log ./program`
- **출력**: 호출된 시스템 콜, 인자, 반환값, 실행 시간 등

### macOS: dtruss

- **용도**: macOS에서 시스템 콜 추적 (Linux의 strace와 유사)
- **사용법**: `sudo dtruss ./program` 또는 `sudo dtruss -p <PID>`
- **제한사항**:
  - **관리자 권한 필요**: `sudo` 필수
  - **System Integrity Protection (SIP)**: macOS의 보안 기능으로 인해 일부 기능 제한
  - **"translated processes" 오류**:
    - 특정 방식으로 컴파일된 바이너리(예: Go 바이너리)는 직접 추적 불가
    - Rosetta 2로 번역된 프로세스 추적 불가
    - 보호된 프로세스 추적 불가
    - **해결책**: 실행 중인 프로세스의 PID로 추적 (`sudo dtruss -p <PID>`)

### 오류 분석: "DTrace cannot instrument translated processes"

이 오류가 발생하는 이유:

1. **보안 메커니즘**: macOS의 System Integrity Protection이 특정 프로세스 보호
2. **바이너리 특성**: Go로 컴파일된 바이너리는 특정 보호 메커니즘이 적용될 수 있음
3. **아키텍처 변환**: Rosetta 2로 변환된 프로세스는 추적 불가
4. **프로세스 상태**: 이미 실행 중이거나 특정 상태의 프로세스는 추적 제한

**의미**:

- 시스템이 보안과 안정성을 위해 특정 프로세스의 추적을 제한함
- 이는 커널 모드와 사용자 모드 분리의 보안 정책과 관련됨
- 모든 프로세스를 자유롭게 추적할 수 있다면 보안 위험이 있음

### Linux vs macOS 차이점

| 항목        | Linux (strace)    | macOS (dtruss)                |
| ----------- | ----------------- | ----------------------------- |
| 권한        | 일반 사용자 가능  | sudo 필요                     |
| 보안 제한   | 상대적으로 적음   | SIP로 인한 제한 많음          |
| 추적 범위   | 대부분의 프로세스 | 제한적 (보호된 프로세스 제외) |
| 사용 편의성 | 높음              | 낮음 (권한 및 제한)           |

## 시스템 성능 모니터링 도구

시스템의 리소스 사용량을 실시간으로 관찰하고 분석하는 도구들입니다.

### sar (System Activity Reporter)

- **개념**: 시스템 활동을 수집하고 보고하는 도구
- **원리**:
  - 백그라운드에서 주기적으로 시스템 통계를 수집
  - CPU, 메모리, 디스크 I/O, 네트워크 등의 성능 데이터 기록
  - 과거 데이터를 저장하여 추세 분석 가능
- **주요 기능**:
  - CPU 사용률: `sar -u`
  - 메모리 사용률: `sar -r`
  - 디스크 I/O: `sar -d`
  - 네트워크 통계: `sar -n`
- **사용 예시**:
  ```bash
  sar -u 1 10  # CPU 사용률을 1초마다 10번 출력
  sar -r 1 5   # 메모리 사용률을 1초마다 5번 출력
  ```

### vm_stat (Virtual Memory Statistics)

- **개념**: 가상 메모리 통계를 실시간으로 표시하는 도구
- **원리**:
  - 커널의 가상 메모리 서브시스템에서 통계 정보를 읽어옴
  - 페이지 단위로 메모리 사용량을 추적
  - 활성/비활성 페이지, 캐시, 스왑 등의 정보 제공
- **주요 정보**:
  - 활성 페이지(Active pages): 현재 사용 중인 메모리
  - 비활성 페이지(Inactive pages): 최근에 사용되지 않은 메모리
  - 캐시(Cache): 파일 시스템 캐시
  - 스왑(Swap): 디스크로 스왑된 메모리
- **사용 예시**:
  ```bash
  vm_stat        # 현재 상태 한 번 출력
  vm_stat 1      # 1초마다 계속 업데이트
  ```

### iostat (I/O Statistics)

- **개념**: CPU와 입출력 장치의 통계를 모니터링하는 도구
- **원리**:
  - 커널의 I/O 서브시스템에서 통계를 수집
  - 디스크 읽기/쓰기 속도, 대기 시간, 사용률 등을 측정
  - CPU 사용률도 함께 표시
- **주요 정보**:
  - 디스크 읽기/쓰기 속도 (KB/s)
  - I/O 대기 시간 (await)
  - 디스크 사용률 (%util)
  - CPU 사용률
- **사용 예시**:
  ```bash
  iostat          # 현재 상태 출력
  iostat -w 1     # 1초마다 업데이트
  iostat -x       # 확장 통계 정보
  ```

### top / htop

- **개념**: 실시간으로 실행 중인 프로세스와 시스템 리소스 사용량을 표시
- **원리**:
  - 커널의 프로세스 테이블과 리소스 통계를 주기적으로 읽어옴
  - CPU, 메모리 사용량이 높은 프로세스를 상위에 표시
  - 인터랙티브하게 정렬, 필터링 가능
- **주요 정보**:
  - CPU 사용률 (전체 및 프로세스별)
  - 메모리 사용량 (전체 및 프로세스별)
  - 실행 중인 프로세스 목록
  - 로드 평균 (Load Average)
- **사용 예시**:
  ```bash
  top             # 기본 모드
  top -o cpu      # CPU 사용률 순으로 정렬
  htop            # 향상된 인터페이스 (설치 필요)
  ```

## 라이브러리 의존성 확인 도구

실행 파일이 어떤 라이브러리에 의존하는지 확인하는 도구들입니다.

### ldd (List Dynamic Dependencies)

- **개념**: ELF 바이너리가 링크된 동적 라이브러리 목록을 표시
- **원리**:
  - ELF 바이너리의 동적 링킹 정보를 읽어옴
  - `.dynamic` 섹션에서 필요한 공유 라이브러리 목록 추출
  - 각 라이브러리의 실제 경로와 버전 정보 표시
- **주요 정보**:
  - 필요한 공유 라이브러리 목록
  - 라이브러리 경로
  - 호환성 버전 정보
- **사용 예시**:
  ```bash
  ldd /bin/echo           # echo의 라이브러리 의존성
  ldd ./my_program        # 현재 디렉토리의 프로그램 확인
  ```

### otool -L (Object Tool - Libraries)

- **개념**: Mach-O 바이너리의 링크 편집 정보를 표시하는 도구
- **원리**:
  - Mach-O 바이너리의 Load Commands를 분석
  - `LC_LOAD_DYLIB` 명령에서 동적 라이브러리 정보 추출
  - 라이브러리 경로와 버전 호환성 정보 표시
- **주요 정보**:
  - 링크된 동적 라이브러리 목록
  - 라이브러리 경로 (install name)
  - 호환성 버전 (compatibility version)
  - 현재 버전 (current version)
- **사용 예시**:
  ```bash
  otool -L /bin/echo              # echo의 라이브러리 의존성
  otool -L $(which python3)        # python3의 라이브러리 의존성
  otool -L ./my_program           # 현재 디렉토리의 프로그램 확인
  ```

## 정적 라이브러리와 공유 라이브러리

라이브러리는 재사용 가능한 코드를 모아놓은 것으로, 프로그램에 포함되는 방식에 따라 정적 라이브러리와 공유 라이브러리로 나뉩니다.

### 정적 라이브러리 (Static Library)

- **개념**: 컴파일 시점에 실행 파일에 직접 포함되는 라이브러리
- **원리**:
  - 라이브러리 코드가 목적 파일(object file)들의 아카이브(archive) 형태로 저장됨
  - 링커(linker)가 컴파일 시 라이브러리 코드를 실행 파일에 복사
  - 실행 파일이 독립적으로 실행 가능 (외부 의존성 없음)
- **파일 형식**:
  - Linux: `.a` (archive) 파일
  - macOS: `.a` 파일
  - 예: `libmath.a`, `libc.a`
- **장점**:
  1. **독립성**: 외부 라이브러리 파일이 없어도 실행 가능
  2. **성능**: 런타임 라이브러리 로딩 오버헤드 없음
  3. **버전 호환성**: 특정 라이브러리 버전에 고정되어 버전 충돌 없음
- **단점**:
  1. **파일 크기**: 실행 파일 크기가 커짐 (라이브러리 코드가 중복 포함)
  2. **메모리 사용**: 같은 라이브러리를 사용하는 여러 프로그램이 각각 메모리에 로드
  3. **업데이트**: 라이브러리 업데이트 시 모든 프로그램을 재컴파일해야 함
- **사용 예시**:

  ```bash
  # 정적 라이브러리 생성
  ar rcs libmath.a math.o calc.o

  # 정적 링킹으로 컴파일
  gcc -static main.c -L. -lmath -o main

  # 의존성 확인 (의존성이 거의 없음)
  ldd main  # "not a dynamic executable" 또는 의존성 없음
  ```

### 공유 라이브러리 (Shared Library / Dynamic Library)

- **개념**: 실행 시점에 동적으로 로드되는 라이브러리
- **원리**:
  - 라이브러리 코드가 별도의 파일로 존재
  - 실행 파일에는 라이브러리 참조 정보만 포함
  - 프로그램 실행 시 동적 링커(ld.so 또는 dyld)가 라이브러리를 메모리에 로드
  - 여러 프로그램이 같은 라이브러리 파일을 공유하여 메모리에 한 번만 로드
- **파일 형식**:
  - Linux: `.so` (shared object) 파일
  - macOS: `.dylib` (dynamic library) 파일
  - Windows: `.dll` (dynamic link library) 파일
  - 예: `libc.so.6`, `libmath.dylib`
- **장점**:
  1. **메모리 효율**: 여러 프로그램이 같은 라이브러리를 공유하여 메모리 절약
  2. **파일 크기**: 실행 파일 크기가 작음 (라이브러리 코드 미포함)
  3. **업데이트**: 라이브러리만 업데이트하면 모든 프로그램에 반영
  4. **유연성**: 런타임에 필요한 라이브러리만 로드 가능
- **단점**:
  1. **의존성**: 실행 시 라이브러리 파일이 반드시 필요
  2. **버전 충돌**: 다른 버전의 라이브러리가 필요할 수 있음
  3. **성능**: 런타임 라이브러리 로딩 오버헤드 (보통 미미함)
- **동적 로딩 과정**:
  ```
  1. 프로그램 실행 시작
  2. 동적 링커가 실행 파일의 라이브러리 의존성 확인
  3. 라이브러리 검색 경로에서 필요한 라이브러리 찾기
     - Linux: LD_LIBRARY_PATH, /etc/ld.so.conf
     - macOS: DYLD_LIBRARY_PATH, /usr/lib 등
  4. 라이브러리를 메모리에 로드 (이미 로드된 경우 재사용)
  5. 심볼(symbol) 해석 및 주소 연결
  6. 프로그램 실행 계속
  ```
- **사용 예시**:

  ```bash
  # 공유 라이브러리 생성
  gcc -shared -fPIC math.c calc.c -o libmath.so

  # 동적 링킹으로 컴파일
  gcc main.c -L. -lmath -o main

  # 의존성 확인
  ldd main  # libmath.so 의존성 표시

  # 라이브러리 검색 경로 설정
  export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH
  ```

### 정적 링킹 vs 동적 링킹 비교

| 항목                     | 정적 링킹            | 동적 링킹                 |
| ------------------------ | -------------------- | ------------------------- |
| **라이브러리 포함 시점** | 컴파일 시            | 실행 시                   |
| **실행 파일 크기**       | 큼                   | 작음                      |
| **메모리 사용**          | 각 프로그램마다 독립 | 여러 프로그램이 공유      |
| **외부 의존성**          | 없음                 | 필요                      |
| **업데이트**             | 재컴파일 필요        | 라이브러리만 업데이트     |
| **성능**                 | 약간 빠름            | 약간 느림 (로딩 오버헤드) |
| **호환성**               | 버전 고정            | 버전 충돌 가능            |

### 실제 사용 예시

```c
// math_lib.c - 라이브러리 소스
int add(int a, int b) {
    return a + b;
}

// main.c - 프로그램 소스
#include <stdio.h>
extern int add(int a, int b);

int main() {
    printf("%d\n", add(3, 4));
    return 0;
}
```

```bash
# 정적 링킹
gcc -c math_lib.c -o math_lib.o
ar rcs libmath.a math_lib.o
gcc -static main.c -L. -lmath -o main_static
# 결과: main_static은 libmath.a의 코드가 포함됨

# 동적 링킹
gcc -shared -fPIC math_lib.c -o libmath.so
gcc main.c -L. -lmath -o main_dynamic
# 결과: main_dynamic은 libmath.so를 참조만 함
```

## 패키지 관리 도구

시스템에 설치된 소프트웨어 패키지를 관리하는 도구들입니다.

### dpkg / apt (Debian/Ubuntu)

- **개념**: Debian 계열 Linux의 패키지 관리 시스템
- **원리**:
  - `.deb` 패키지 형식 사용
  - 패키지 메타데이터를 데이터베이스에 저장
  - 의존성 해결 및 충돌 방지
- **주요 명령어**:
  ```bash
  dpkg-query -W              # 설치된 모든 패키지 목록
  dpkg-query -s <package>     # 특정 패키지 정보
  dpkg -l | grep ^lib         # lib로 시작하는 패키지 검색
  apt list --installed        # apt로 설치된 패키지 목록
  ```

### brew (Homebrew)

- **개념**: macOS의 패키지 관리자
- **원리**:
  - 소스 코드를 다운로드하여 컴파일하거나 바이너리 설치
  - `/usr/local` 또는 `/opt/homebrew`에 설치
  - 의존성을 자동으로 해결
- **주요 명령어**:
  ```bash
  brew list                   # 설치된 패키지 목록
  brew list | grep ^lib       # lib로 시작하는 패키지 검색
  brew info <package>         # 패키지 정보 확인
  brew search <keyword>       # 패키지 검색
  ```

### 시스템 라이브러리 위치

- **Linux**:

  - `/usr/lib`: 시스템 라이브러리
  - `/lib`: 기본 라이브러리
  - `/usr/local/lib`: 로컬 설치 라이브러리

- **macOS**:
  - `/usr/lib`: 시스템 라이브러리
  - `/usr/local/lib`: Homebrew 등으로 설치된 라이브러리
  - `/opt/homebrew/lib`: Apple Silicon Mac의 Homebrew 라이브러리
