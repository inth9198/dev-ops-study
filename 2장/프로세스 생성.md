# 프로세스 생성

## 프로세스를 생성하는 목적

프로세스 생성은 운영체제에서 여러 작업을 동시에 수행하고, 시스템의 효율성을 높이기 위한 핵심 메커니즘입니다.

### 주요 목적

1. **멀티태스킹 (Multitasking)**

   - 여러 작업을 동시에 실행하여 시스템 활용도 향상
   - 사용자는 여러 프로그램을 동시에 사용 가능
   - 예: 웹 브라우저를 사용하면서 음악을 재생하고 파일을 다운로드

2. **작업 분리 (Task Isolation)**

   - 각 프로세스는 독립적인 메모리 공간을 가짐
   - 한 프로세스의 오류가 다른 프로세스에 영향을 주지 않음
   - 시스템 안정성과 보안 향상

3. **병렬 처리 (Parallel Processing)**

   - CPU 코어가 여러 개일 때 각 코어에서 다른 프로세스 실행
   - 작업을 여러 프로세스로 분할하여 처리 속도 향상
   - 예: 웹 서버가 여러 클라이언트 요청을 동시에 처리

4. **서비스 제공 (Service Provisioning)**

   - 백그라운드에서 지속적으로 실행되는 데몬 프로세스
   - 시스템 서비스 제공 (예: 웹 서버, 데이터베이스 서버)
   - 사용자 요청에 따라 새로운 프로세스 생성하여 응답

5. **프로세스 계층 구조 (Process Hierarchy)**

   - 부모-자식 관계를 통한 프로세스 관리
   - 프로세스 그룹과 세션 관리
   - 리소스 관리 및 권한 상속

6. **프로그램 실행 (Program Execution)**
   - 사용자가 프로그램을 실행할 때마다 새로운 프로세스 생성
   - 각 프로그램이 독립적인 실행 환경에서 동작
   - 프로그램 간 간섭 없이 실행

## fork() 함수

`fork()`는 새로운 프로세스를 생성하는 시스템 콜로, 현재 프로세스의 복사본을 만들어 자식 프로세스를 생성합니다.

### 개념

- **정의**: 현재 실행 중인 프로세스를 복제하여 새로운 자식 프로세스를 생성
- **원리**:
  - 부모 프로세스의 메모리 공간, 파일 디스크립터, 환경 변수 등을 복사
  - 부모와 자식 프로세스는 거의 동일한 상태로 시작
  - 반환값으로 부모와 자식을 구분

### 동작 방식

1. **프로세스 복제**:

   - 부모 프로세스의 메모리 공간 전체를 복사 (Copy-on-Write 최적화 사용)
   - 프로세스 제어 블록(PCB) 복사
   - 파일 디스크립터 테이블 복사

2. **반환값**:

   - **부모 프로세스**: 자식 프로세스의 PID(Process ID) 반환
   - **자식 프로세스**: 0 반환
   - **실패 시**: -1 반환 (에러 발생)

3. **실행 흐름**:
   ```
   부모 프로세스
     ↓
   fork() 호출
     ↓
   ┌─────────────┬─────────────┐
   │ 부모 프로세스 │ 자식 프로세스 │
   │ (PID 반환)  │ (0 반환)     │
   └─────────────┴─────────────┘
     ↓              ↓
   부모 코드 실행   자식 코드 실행
   (동시 실행)
   ```

### 함수 시그니처

```c
#include <unistd.h>

pid_t fork(void);
```

- **반환값**:
  - 성공 시: 부모는 자식의 PID, 자식은 0
  - 실패 시: -1 (errno 설정)

### 기본 사용 예시

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t pid;

    printf("부모 프로세스 시작 (PID: %d)\n", getpid());

    pid = fork();

    if (pid < 0) {
        // fork() 실패
        perror("fork 실패");
        return 1;
    } else if (pid == 0) {
        // 자식 프로세스
        printf("자식 프로세스 (PID: %d, 부모 PID: %d)\n",
               getpid(), getppid());
    } else {
        // 부모 프로세스
        printf("부모 프로세스 (자식 PID: %d)\n", pid);
    }

    return 0;
}
```

**실행 결과 예시**:

```
부모 프로세스 시작 (PID: 1234)
부모 프로세스 (자식 PID: 1235)
자식 프로세스 (PID: 1235, 부모 PID: 1234)
```

### fork()의 특징

1. **메모리 복사**:

   - 부모의 모든 메모리 공간을 복사 (초기에는)
   - Copy-on-Write(COW) 최적화: 실제 수정이 발생할 때만 복사
   - 메모리 효율성 향상

2. **파일 디스크립터 공유**:

   - 부모와 자식이 같은 파일 디스크립터를 공유
   - 파일 포인터 위치도 공유됨
   - 주의: 동시에 같은 파일을 읽고 쓸 때 충돌 가능

3. **독립적인 실행**:

   - 부모와 자식은 서로 독립적으로 실행
   - 한 프로세스의 변경이 다른 프로세스에 영향을 주지 않음
   - 각각의 스택, 힙, 데이터 영역을 가짐

4. **프로세스 ID**:
   - 부모: `getpid()`로 자신의 PID, `fork()` 반환값으로 자식 PID
   - 자식: `getpid()`로 자신의 PID, `getppid()`로 부모 PID

### fork() 사용 시나리오

1. **멀티프로세스 서버**:

   ```c
   while (1) {
       int client_fd = accept(...);
       pid_t pid = fork();

       if (pid == 0) {
           // 자식: 클라이언트 요청 처리
           handle_client(client_fd);
           exit(0);
       }
       // 부모: 다음 연결 대기
   }
   ```

2. **병렬 작업 처리**:

   ```c
   for (int i = 0; i < num_tasks; i++) {
       if (fork() == 0) {
           // 자식: 작업 수행
           process_task(i);
           exit(0);
       }
   }
   // 부모: 모든 자식 완료 대기
   ```

3. **새로운 프로그램 실행 전 준비**:
   ```c
   pid_t pid = fork();
   if (pid == 0) {
       // 자식: exec()로 새 프로그램 실행
       execl("/bin/ls", "ls", "-l", NULL);
   }
   // 부모: 자식 완료 대기
   wait(NULL);
   ```

### 주의사항

1. **무한 루프 주의**:

   - `fork()`를 반복문에서 잘못 사용하면 프로세스가 기하급수적으로 증가
   - 예: `while(1) fork();` → 포크 봄(Fork Bomb)

2. **자식 프로세스 정리**:

   - 자식 프로세스가 종료되면 좀비 프로세스가 될 수 있음
   - `wait()` 또는 `waitpid()`로 자식 프로세스 종료 대기 필요

3. **메모리 사용량**:

   - 많은 프로세스를 생성하면 메모리 사용량이 증가
   - Copy-on-Write로 최적화되지만 여전히 주의 필요

4. **동기화**:
   - 부모와 자식이 동시에 실행되므로 동기화 메커니즘 필요
   - 파이프, 시그널, 공유 메모리 등을 사용하여 통신

## execve() 함수

`execve()`는 현재 프로세스의 메모리 이미지를 새로운 프로그램으로 교체하는 시스템 콜입니다.

### 개념

- **정의**: 현재 실행 중인 프로세스의 코드와 데이터를 새로운 프로그램으로 완전히 교체
- **원리**:
  - 프로세스 ID(PID)는 유지되지만 메모리 내용이 새 프로그램으로 교체됨
  - `fork()`와 함께 사용하여 새로운 프로그램 실행
  - 프로세스 생성 없이 프로그램만 교체

### 동작 방식

1. **프로세스 이미지 교체**:

   - 현재 프로세스의 텍스트(코드) 세그먼트를 새 프로그램으로 교체
   - 데이터 세그먼트와 힙을 새 프로그램의 초기값으로 설정
   - 스택을 새로 초기화

2. **프로세스 속성 유지**:

   - 프로세스 ID(PID) 유지
   - 부모 프로세스 ID(PPID) 유지
   - 파일 디스크립터 유지 (close-on-exec 플래그가 없는 경우)
   - 프로세스 그룹 ID, 세션 ID 유지

3. **실행 흐름**:
   ```
   현재 프로세스
     ↓
   execve() 호출
     ↓
   프로그램 파일 로드
     ↓
   메모리 이미지 교체
     ↓
   새 프로그램 실행 시작
   (execve() 이후 코드는 실행되지 않음)
   ```

### 함수 시그니처

```c
#include <unistd.h>

int execve(const char *pathname, char *const argv[], char *const envp[]);
```

- **매개변수**:
  - `pathname`: 실행할 프로그램의 경로
  - `argv`: 프로그램에 전달할 인자 배열 (argv[0]은 보통 프로그램 이름)
  - `envp`: 환경 변수 배열
- **반환값**:
  - 성공 시: 반환하지 않음 (프로세스가 교체되므로)
  - 실패 시: -1 (errno 설정)

### 기본 사용 예시

```c
#include <unistd.h>
#include <stdio.h>

int main() {
    char *argv[] = {"/bin/ls", "-l", NULL};
    char *envp[] = {"PATH=/usr/bin:/bin", "HOME=/home/user", NULL};

    printf("execve() 호출 전\n");

    execve("/bin/ls", argv, envp);

    // 이 코드는 실행되지 않음 (프로세스가 교체되었으므로)
    perror("execve 실패");
    return 1;
}
```

### exec 계열 함수들

- **execve()**: 가장 기본적인 함수, 경로와 환경 변수를 직접 지정
- **execl()**: 인자를 개별적으로 전달
- **execv()**: 인자를 배열로 전달
- **execle()**: 환경 변수를 지정
- **execlp()**: PATH 환경 변수에서 프로그램 검색
- **execvp()**: PATH에서 검색하며 인자를 배열로 전달

### fork()와 execve()의 조합

일반적으로 `fork()`와 `execve()`를 함께 사용하여 새 프로그램을 실행합니다:

```c
pid_t pid = fork();

if (pid == 0) {
    // 자식 프로세스: 새 프로그램 실행
    execve("/bin/ls", argv, envp);
    perror("execve 실패");
    exit(1);
} else if (pid > 0) {
    // 부모 프로세스: 자식 완료 대기
    wait(NULL);
}
```

## ASLR (Address Space Layout Randomization)

### 개념

- **정의**: 프로세스의 메모리 레이아웃을 랜덤하게 배치하여 보안 공격을 어렵게 만드는 보안 기법
- **목적**: 버퍼 오버플로우 등 메모리 공격을 방어

### 원리

1. **메모리 주소 랜덤화**:

   - 스택, 힙, 라이브러리, 실행 코드의 메모리 주소를 매번 다르게 배치
   - 공격자가 특정 메모리 주소를 예측하기 어렵게 만듦

2. **보안 효과**:

   - 버퍼 오버플로우 공격 시 반환 주소를 예측하기 어려움
   - Return-to-libc 공격 방어
   - ROP (Return-Oriented Programming) 공격 완화

3. **구현 방식**:
   - 커널이 프로세스 생성 시 메모리 영역의 시작 주소를 랜덤하게 선택
   - 각 프로세스마다 다른 메모리 레이아웃 할당

### 확인 방법

```bash
# ASLR 상태 확인 (Linux)
cat /proc/sys/kernel/randomize_va_space
# 0: 비활성화, 1: 부분 활성화, 2: 완전 활성화

# 프로세스의 메모리 맵 확인
cat /proc/<PID>/maps
```

## 프로세스의 부모-자식 관계

### 개념

- **부모 프로세스 (Parent Process)**: 다른 프로세스를 생성한 프로세스
- **자식 프로세스 (Child Process)**: `fork()`에 의해 생성된 프로세스
- **프로세스 트리**: 모든 프로세스는 부모-자식 관계로 트리 구조를 형성

### 관계의 특징

1. **PID와 PPID**:

   - 각 프로세스는 고유한 PID (Process ID)를 가짐
   - PPID (Parent Process ID)로 부모 프로세스를 식별
   - `getpid()`: 자신의 PID 반환
   - `getppid()`: 부모의 PID 반환

2. **리소스 상속**:

   - 파일 디스크립터 상속
   - 환경 변수 상속
   - 작업 디렉토리 상속
   - 사용자 ID, 그룹 ID 상속

3. **프로세스 계층 구조**:
   ```
   init (PID 1)
   ├── systemd / launchd
   │   ├── sshd
   │   │   └── bash
   │   │       └── ls
   │   └── httpd
   │       ├── worker 1
   │       └── worker 2
   ```

### 프로세스 트리 확인

```bash
# 프로세스 트리 확인
pstree
pstree -p  # PID 포함

# 특정 프로세스의 부모 확인
ps -o pid,ppid,cmd -p <PID>
```

## 프로세스 상태

프로세스는 실행 중 다양한 상태를 거치며 전환됩니다.

### 주요 프로세스 상태

1. **Running (실행 중, R)**:

   - CPU에서 실행 중이거나 실행 대기 중
   - 실행 가능한 상태

2. **Sleeping (대기 중, S)**:

   - I/O 작업이나 이벤트를 기다리는 상태
   - 인터럽트 가능한 대기 (interruptible sleep)

3. **Uninterruptible Sleep (D)**:

   - 디스크 I/O 등 중요한 작업을 기다리는 상태
   - 시그널로 깨울 수 없음

4. **Stopped (T)**:

   - 시그널(SIGSTOP, SIGTSTP)에 의해 일시 정지된 상태
   - SIGCONT 시그널로 재개 가능

5. **Zombie (Z)**:
   - 프로세스가 종료되었지만 부모가 종료 상태를 회수하지 않은 상태
   - 프로세스 테이블에만 남아있음

### 상태 전환

```
생성 (fork)
  ↓
Ready (준비)
  ↓
Running (실행)
  ↓
Sleeping (대기) ←→ Running
  ↓
Terminated (종료)
  ↓
Zombie (좀비) → 회수 (wait)
```

### 프로세스 상태 확인

```bash
# 프로세스 상태 확인
ps aux
ps -eo pid,state,cmd

# 실시간 모니터링
top
htop
```

## 프로세스 종료

프로세스가 정상적으로 또는 비정상적으로 종료되는 과정입니다.

### 종료 방법

1. **정상 종료**:

   - `exit()` 함수 호출
   - `main()` 함수에서 `return`
   - 프로그램이 정상적으로 완료

2. **시그널에 의한 종료**:

   - `SIGTERM`: 정상 종료 요청
   - `SIGKILL`: 강제 종료 (처리 불가)
   - `SIGINT`: 인터럽트 (Ctrl+C)

3. **에러로 인한 종료**:
   - 세그먼테이션 폴트 (SIGSEGV)
   - 부동소수점 예외 (SIGFPE)
   - 잘못된 명령어 (SIGILL)

### exit() 함수

```c
#include <stdlib.h>

void exit(int status);
```

- **기능**: 프로세스를 정상적으로 종료
- **status**: 종료 상태 코드 (0: 성공, 그 외: 실패)
- **동작**:
  1. 종료 핸들러 실행
  2. 버퍼 플러시
  3. 열린 파일 닫기
  4. 부모에게 종료 상태 전달

### 종료 상태 확인

```bash
# 마지막 명령의 종료 상태 확인
echo $?

# 0: 성공, 그 외: 실패
```

## 좀비 프로세스와 고아 프로세스

### 좀비 프로세스 (Zombie Process)

- **개념**: 종료되었지만 부모 프로세스가 종료 상태를 회수하지 않은 프로세스
- **원인**:
  - 자식 프로세스가 종료되었지만 부모가 `wait()` 또는 `waitpid()`를 호출하지 않음
  - 프로세스 테이블에만 남아있고 실제 메모리는 해제됨
- **문제점**:
  - 프로세스 테이블 슬롯을 차지
  - 많은 좀비 프로세스가 있으면 새 프로세스 생성 불가
- **해결 방법**:
  ```c
  // 부모 프로세스에서
  wait(NULL);  // 자식 프로세스 종료 대기
  // 또는
  waitpid(pid, NULL, 0);
  ```
- **확인 방법**:
  ```bash
  ps aux | grep Z
  ```

### 고아 프로세스 (Orphan Process)

- **개념**: 부모 프로세스가 먼저 종료되어 부모가 없는 프로세스
- **처리 방식**:
  - 고아 프로세스는 init 프로세스(PID 1)의 자식이 됨
  - init 프로세스가 자동으로 `wait()`를 호출하여 좀비가 되지 않도록 함
- **예시**:

  ```c
  pid_t pid = fork();

  if (pid == 0) {
      // 자식 프로세스
      sleep(10);  // 부모가 먼저 종료되면 고아가 됨
      // 이제 부모는 init (PID 1)
  } else {
      // 부모 프로세스
      exit(0);  // 자식을 기다리지 않고 종료
  }
  ```

## 시그널 (Signal)

시그널은 프로세스 간 통신과 프로세스 제어를 위한 메커니즘입니다.

### 개념

- **정의**: 프로세스에게 특정 이벤트가 발생했음을 알리는 비동기 메커니즘
- **원리**: 커널이 프로세스에게 시그널을 전달하고, 프로세스는 시그널 핸들러로 처리

### 주요 시그널

| 시그널  | 번호 | 의미                    | 기본 동작         |
| ------- | ---- | ----------------------- | ----------------- |
| SIGHUP  | 1    | 터미널 연결 끊김        | 종료              |
| SIGINT  | 2    | 인터럽트 (Ctrl+C)       | 종료              |
| SIGQUIT | 3    | 종료 (Ctrl+\)           | 코어 덤프 후 종료 |
| SIGKILL | 9    | 강제 종료               | 종료 (처리 불가)  |
| SIGTERM | 15   | 종료 요청               | 종료              |
| SIGSTOP | 19   | 일시 정지               | 정지 (처리 불가)  |
| SIGCONT | 18   | 재개                    | 계속 실행         |
| SIGCHLD | 17   | 자식 프로세스 상태 변경 | 무시              |

### 시그널 전송

```c
#include <signal.h>

int kill(pid_t pid, int sig);
```

- **pid**: 시그널을 보낼 프로세스 ID
  - `> 0`: 특정 프로세스
  - `0`: 같은 프로세스 그룹
  - `-1`: 모든 프로세스 (권한 필요)
- **sig**: 전송할 시그널 번호

### 시그널 핸들러 등록

```c
#include <signal.h>

void signal_handler(int sig) {
    printf("시그널 %d 수신\n", sig);
}

int main() {
    signal(SIGINT, signal_handler);  // SIGINT 핸들러 등록
    // 또는
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigaction(SIGINT, &sa, NULL);

    while(1) {
        pause();  // 시그널 대기
    }
}
```

### 시그널 블로킹

```c
sigset_t set;
sigemptyset(&set);
sigaddset(&set, SIGINT);
sigprocmask(SIG_BLOCK, &set, NULL);  // SIGINT 블로킹
```

## 셸 작업 관리 구현

셸(Shell)은 백그라운드 작업과 포그라운드 작업을 관리합니다.

### 포그라운드 작업 (Foreground Job)

- **개념**: 사용자 입력을 받고 터미널 출력을 표시하는 작업
- **특징**:
  - 터미널을 독점
  - Ctrl+C로 중단 가능
  - 작업이 완료될 때까지 다음 명령 입력 불가

### 백그라운드 작업 (Background Job)

- **개념**: 터미널과 독립적으로 실행되는 작업
- **실행 방법**:
  ```bash
  command &  # 명령어 끝에 & 추가
  ```
- **특징**:
  - 터미널을 차단하지 않음
  - 즉시 다음 명령 입력 가능
  - 작업 ID(Job ID)로 관리

### 작업 관리 명령어

```bash
# 백그라운드로 실행
sleep 100 &

# 실행 중인 작업 확인
jobs

# 작업을 포그라운드로 가져오기
fg %1  # 작업 1번을 포그라운드로

# 작업을 백그라운드로 보내기
bg %1  # 작업 1번을 백그라운드로

# 작업 종료
kill %1  # 작업 1번 종료
```

### 구현 원리

1. **프로세스 그룹**:

   - 셸이 생성한 작업은 같은 프로세스 그룹에 속함
   - 프로세스 그룹에 시그널을 보내면 모든 프로세스에 전달

2. **터미널 제어**:

   - 포그라운드 작업: 터미널의 제어 터미널(controlling terminal)이 됨
   - 백그라운드 작업: 제어 터미널이 없음

3. **시그널 처리**:
   - Ctrl+C: SIGINT를 포그라운드 프로세스 그룹에 전송
   - Ctrl+Z: SIGTSTP를 포그라운드 프로세스 그룹에 전송

## 세션 (Session)

### 개념

- **정의**: 하나 이상의 프로세스 그룹을 포함하는 논리적 단위
- **목적**: 로그인 세션과 터미널 세션을 관리

### 세션의 특징

1. **세션 리더 (Session Leader)**:

   - 세션을 생성한 프로세스
   - 세션 ID(SID)는 세션 리더의 PID와 같음
   - 일반적으로 셸 프로세스

2. **제어 터미널 (Controlling Terminal)**:

   - 세션에 연결된 터미널
   - 한 세션은 최대 하나의 제어 터미널을 가짐
   - 포그라운드 프로세스 그룹만 제어 터미널과 상호작용

3. **세션 생성**:
   ```c
   pid_t setsid(void);
   ```
   - 새로운 세션을 생성하고 호출 프로세스를 세션 리더로 만듦
   - 제어 터미널과의 연결을 끊음

### 세션 확인

```bash
# 프로세스의 세션 ID 확인
ps -eo pid,sid,tty,cmd

# 세션 리더 확인
ps -p $(ps -o sid= -p <PID>)
```

## 프로세스 그룹 (Process Group)

### 개념

- **정의**: 관련된 프로세스들의 집합
- **목적**: 시그널을 그룹 단위로 전송하고 관리

### 프로세스 그룹의 특징

1. **프로세스 그룹 ID (PGID)**:

   - 각 프로세스 그룹은 고유한 PGID를 가짐
   - 프로세스 그룹 리더의 PID가 PGID가 됨

2. **그룹 리더 (Group Leader)**:

   - 프로세스 그룹을 생성한 프로세스
   - 일반적으로 셸이 생성한 작업의 첫 번째 프로세스

3. **시그널 전송**:
   - 프로세스 그룹에 시그널을 보내면 그룹의 모든 프로세스에 전달
   - 예: `kill -SIGINT -<PGID>` (음수는 프로세스 그룹을 의미)

### 프로세스 그룹 생성

```c
#include <unistd.h>

pid_t setpgid(pid_t pid, pid_t pgid);
```

- **pid**: 프로세스 ID (0이면 현재 프로세스)
- **pgid**: 프로세스 그룹 ID (0이면 pid를 PGID로 사용)

### 프로세스 그룹 확인

```bash
# 프로세스 그룹 정보 확인
ps -eo pid,pgid,sid,tty,cmd

# 특정 프로세스 그룹의 모든 프로세스
ps -g <PGID>
```

## 데몬 (Daemon)

### 개념

- **정의**: 백그라운드에서 지속적으로 실행되는 시스템 서비스 프로세스
- **특징**: 사용자와 직접 상호작용하지 않고 시스템 서비스를 제공

### 데몬의 특징

1. **독립 실행**:

   - 부모 프로세스와 분리
   - 제어 터미널이 없음
   - init 프로세스의 자식이 됨

2. **백그라운드 실행**:

   - 터미널과 독립적으로 실행
   - 사용자 로그아웃 후에도 계속 실행

3. **시스템 서비스**:
   - 웹 서버, 데이터베이스 서버, 로그 데몬 등
   - 시스템 부팅 시 자동 시작

### 데몬 생성 과정

```c
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>

int main() {
    pid_t pid;

    // 1. fork()로 자식 프로세스 생성
    pid = fork();
    if (pid < 0) {
        exit(1);
    }

    // 2. 부모 프로세스 종료 (자식이 init의 자식이 됨)
    if (pid > 0) {
        exit(0);
    }

    // 3. 새로운 세션 생성 (제어 터미널 분리)
    if (setsid() < 0) {
        exit(1);
    }

    // 4. 다시 fork() (세션 리더가 되지 않도록)
    pid = fork();
    if (pid < 0) {
        exit(1);
    }
    if (pid > 0) {
        exit(0);
    }

    // 5. 작업 디렉토리 변경
    chdir("/");

    // 6. 파일 모드 마스크 설정
    umask(0);

    // 7. 표준 입출력 닫기
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);

    // 8. 데몬 작업 수행
    while (1) {
        // 데몬 로직
        sleep(1);
    }

    return 0;
}
```

### 데몬 확인

```bash
# 실행 중인 데몬 확인
ps aux | grep -E '\[.*\]$'  # 커널 스레드는 [ ]로 표시

# 시스템 서비스 확인 (systemd)
systemctl list-units --type=service

# 실행 중인 데몬 프로세스
ps -eo pid,ppid,sid,tty,cmd | grep -v '?' | grep -v 'tty'
```

### 주요 데몬 예시

- **sshd**: SSH 서버 데몬
- **httpd / nginx**: 웹 서버 데몬
- **mysqld**: MySQL 데이터베이스 데몬
- **syslogd**: 시스템 로그 데몬
- **cron**: 스케줄 작업 데몬
