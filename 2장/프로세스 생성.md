# 프로세스 생성

## 프로세스를 생성하는 목적

프로세스 생성은 운영체제에서 여러 작업을 동시에 수행하고, 시스템의 효율성을 높이기 위한 핵심 메커니즘입니다.

### 주요 목적

1. **멀티태스킹 (Multitasking)**

   - 여러 작업을 동시에 실행하여 시스템 활용도 향상
   - 사용자는 여러 프로그램을 동시에 사용 가능
   - 예: 웹 브라우저를 사용하면서 음악을 재생하고 파일을 다운로드

2. **작업 분리 (Task Isolation)**

   - 각 프로세스는 독립적인 메모리 공간을 가짐
   - 한 프로세스의 오류가 다른 프로세스에 영향을 주지 않음
   - 시스템 안정성과 보안 향상

3. **병렬 처리 (Parallel Processing)**

   - CPU 코어가 여러 개일 때 각 코어에서 다른 프로세스 실행
   - 작업을 여러 프로세스로 분할하여 처리 속도 향상
   - 예: 웹 서버가 여러 클라이언트 요청을 동시에 처리

4. **서비스 제공 (Service Provisioning)**

   - 백그라운드에서 지속적으로 실행되는 데몬 프로세스
   - 시스템 서비스 제공 (예: 웹 서버, 데이터베이스 서버)
   - 사용자 요청에 따라 새로운 프로세스 생성하여 응답

5. **프로세스 계층 구조 (Process Hierarchy)**

   - 부모-자식 관계를 통한 프로세스 관리
   - 프로세스 그룹과 세션 관리
   - 리소스 관리 및 권한 상속

6. **프로그램 실행 (Program Execution)**
   - 사용자가 프로그램을 실행할 때마다 새로운 프로세스 생성
   - 각 프로그램이 독립적인 실행 환경에서 동작
   - 프로그램 간 간섭 없이 실행

## fork() 함수

`fork()`는 새로운 프로세스를 생성하는 시스템 콜로, 현재 프로세스의 복사본을 만들어 자식 프로세스를 생성합니다.

### 개념

- **정의**: 현재 실행 중인 프로세스를 복제하여 새로운 자식 프로세스를 생성
- **원리**:
  - 부모 프로세스의 메모리 공간, 파일 디스크립터, 환경 변수 등을 복사
  - 부모와 자식 프로세스는 거의 동일한 상태로 시작
  - 반환값으로 부모와 자식을 구분

### 동작 방식

1. **프로세스 복제**:

   - 부모 프로세스의 메모리 공간 전체를 복사 (Copy-on-Write 최적화 사용)
   - 프로세스 제어 블록(PCB) 복사
   - 파일 디스크립터 테이블 복사

2. **반환값**:

   - **부모 프로세스**: 자식 프로세스의 PID(Process ID) 반환
   - **자식 프로세스**: 0 반환
   - **실패 시**: -1 반환 (에러 발생)

3. **실행 흐름**:
   ```
   부모 프로세스
     ↓
   fork() 호출
     ↓
   ┌─────────────┬─────────────┐
   │ 부모 프로세스 │ 자식 프로세스 │
   │ (PID 반환)  │ (0 반환)     │
   └─────────────┴─────────────┘
     ↓              ↓
   부모 코드 실행   자식 코드 실행
   (동시 실행)
   ```

### 함수 시그니처

```c
#include <unistd.h>

pid_t fork(void);
```

- **반환값**:
  - 성공 시: 부모는 자식의 PID, 자식은 0
  - 실패 시: -1 (errno 설정)

### 기본 사용 예시

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t pid;

    printf("부모 프로세스 시작 (PID: %d)\n", getpid());

    pid = fork();

    if (pid < 0) {
        // fork() 실패
        perror("fork 실패");
        return 1;
    } else if (pid == 0) {
        // 자식 프로세스
        printf("자식 프로세스 (PID: %d, 부모 PID: %d)\n",
               getpid(), getppid());
    } else {
        // 부모 프로세스
        printf("부모 프로세스 (자식 PID: %d)\n", pid);
    }

    return 0;
}
```

**실행 결과 예시**:

```
부모 프로세스 시작 (PID: 1234)
부모 프로세스 (자식 PID: 1235)
자식 프로세스 (PID: 1235, 부모 PID: 1234)
```

### fork()의 특징

1. **메모리 복사 (Copy-on-Write)**:

   - **초기 동작**: `fork()` 직후에는 부모와 자식이 같은 물리 메모리를 공유
   - **Copy-on-Write(COW) 최적화**: 
     - 페이지 테이블 항목만 복사하고 메모리 페이지는 읽기 전용으로 공유
     - 부모나 자식이 메모리를 수정할 때만 해당 페이지를 실제로 복사
     - 메모리 사용량 크게 절감 및 fork() 속도 향상
   - **COW의 이점**: 
     - `fork()` 후 즉시 `exec()`를 호출하는 경우 메모리 복사 오버헤드 없음
     - 수정되지 않는 메모리는 영구적으로 공유

2. **파일 디스크립터 공유**:

   - 부모와 자식이 같은 파일 디스크립터를 공유
   - 파일 포인터 위치도 공유됨
   - 주의: 동시에 같은 파일을 읽고 쓸 때 충돌 가능

3. **독립적인 실행**:

   - 부모와 자식은 서로 독립적으로 실행
   - 한 프로세스의 변경이 다른 프로세스에 영향을 주지 않음
   - 각각의 스택, 힙, 데이터 영역을 가짐

4. **프로세스 ID**:
   - 부모: `getpid()`로 자신의 PID, `fork()` 반환값으로 자식 PID
   - 자식: `getpid()`로 자신의 PID, `getppid()`로 부모 PID

### fork() 사용 시나리오

1. **멀티프로세스 서버**:

   ```c
   while (1) {
       int client_fd = accept(...);
       pid_t pid = fork();

       if (pid == 0) {
           // 자식: 클라이언트 요청 처리
           handle_client(client_fd);
           exit(0);
       }
       // 부모: 다음 연결 대기
   }
   ```

2. **병렬 작업 처리**:

   ```c
   for (int i = 0; i < num_tasks; i++) {
       if (fork() == 0) {
           // 자식: 작업 수행
           process_task(i);
           exit(0);
       }
   }
   // 부모: 모든 자식 완료 대기
   ```

3. **새로운 프로그램 실행 전 준비**:
   ```c
   pid_t pid = fork();
   if (pid == 0) {
       // 자식: exec()로 새 프로그램 실행
       execl("/bin/ls", "ls", "-l", NULL);
   }
   // 부모: 자식 완료 대기
   wait(NULL);
   ```

### 주의사항

1. **무한 루프 주의 (Fork Bomb)**:

   - `fork()`를 반복문에서 잘못 사용하면 프로세스가 기하급수적으로 증가
   - 예: `while(1) fork();` → 포크 봄(Fork Bomb)
   - 시스템이 응답 불가 상태가 될 수 있으므로 매우 위험
   - **방어책**: `ulimit -u`로 프로세스 수 제한 설정

2. **자식 프로세스 정리 (좀비 프로세스 방지)**:

   - 자식 프로세스가 종료되면 좀비 프로세스가 될 수 있음
   - `wait()` 또는 `waitpid()`로 자식 프로세스 종료 상태를 회수해야 함
   - 또는 `SIGCHLD` 시그널을 `SIG_IGN`으로 설정하여 자동 회수

3. **메모리 사용량**:

   - 많은 프로세스를 생성하면 메모리 사용량이 증가
   - Copy-on-Write로 최적화되지만, 메모리 수정 시 실제 복사 발생
   - 각 프로세스마다 별도의 페이지 테이블과 커널 자료구조 필요

4. **동기화 및 통신**:
   - 부모와 자식이 비동기적으로 동시에 실행되므로 실행 순서 보장 안 됨
   - **IPC(Inter-Process Communication) 메커니즘**:
     - 파이프 (pipe): 단방향 데이터 스트림
     - 시그널 (signal): 비동기 이벤트 통지
     - 공유 메모리 (shared memory): 고속 데이터 공유
     - 메시지 큐 (message queue): 구조화된 메시지 전달
     - 소켓 (socket): 네트워크 및 로컬 통신

## wait()와 waitpid() 함수

자식 프로세스의 종료를 기다리고 종료 상태를 회수하는 시스템 콜입니다.

### wait() 함수

```c
#include <sys/wait.h>

pid_t wait(int *status);
```

- **기능**: 자식 프로세스 중 하나가 종료될 때까지 대기
- **status**: 자식 프로세스의 종료 상태를 저장할 포인터 (NULL 가능)
- **반환값**: 
  - 성공 시: 종료된 자식의 PID
  - 실패 시: -1 (자식 프로세스가 없는 경우)

### waitpid() 함수

```c
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *status, int options);
```

- **pid**: 
  - `> 0`: 특정 PID를 가진 자식 프로세스 대기
  - `-1`: 임의의 자식 프로세스 대기 (wait()와 동일)
  - `0`: 같은 프로세스 그룹의 자식 대기
  - `< -1`: 프로세스 그룹 ID가 |pid|인 자식 대기
- **options**:
  - `0`: 블로킹 모드 (자식이 종료될 때까지 대기)
  - `WNOHANG`: 논블로킹 모드 (즉시 반환)
  - `WUNTRACED`: 정지된 자식도 보고
  - `WCONTINUED`: 재개된 자식도 보고

### 종료 상태 매크로

```c
// status 값을 해석하는 매크로들
WIFEXITED(status)    // 정상 종료 여부
WEXITSTATUS(status)  // exit() 상태 코드 (0-255)
WIFSIGNALED(status)  // 시그널로 종료되었는지
WTERMSIG(status)     // 종료시킨 시그널 번호
WIFSTOPPED(status)   // 정지되었는지
WSTOPSIG(status)     // 정지시킨 시그널 번호
```

### 사용 예시

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();
    
    if (pid == 0) {
        // 자식 프로세스
        printf("자식 프로세스 실행 중...\n");
        sleep(2);
        exit(42);  // 종료 코드 42
    } else if (pid > 0) {
        // 부모 프로세스
        int status;
        pid_t child_pid = wait(&status);
        
        printf("자식 프로세스 %d 종료\n", child_pid);
        
        if (WIFEXITED(status)) {
            printf("정상 종료, 종료 코드: %d\n", WEXITSTATUS(status));
        } else if (WIFSIGNALED(status)) {
            printf("시그널로 종료, 시그널 번호: %d\n", WTERMSIG(status));
        }
    }
    
    return 0;
}
```

### 좀비 프로세스 방지

```c
// 방법 1: wait()로 명시적 회수
pid_t pid = fork();
if (pid == 0) {
    // 자식 작업
    exit(0);
} else {
    wait(NULL);  // 좀비 방지
}

// 방법 2: SIGCHLD 시그널 핸들러
#include <signal.h>

void sigchld_handler(int sig) {
    while (waitpid(-1, NULL, WNOHANG) > 0);
}

int main() {
    signal(SIGCHLD, sigchld_handler);
    // 또는 자동 회수
    signal(SIGCHLD, SIG_IGN);
    
    // fork() 및 작업...
}

// 방법 3: 이중 fork() (데몬 생성 시)
if (fork() == 0) {
    if (fork() == 0) {
        // 손자 프로세스 - 작업 수행
    }
    exit(0);  // 자식은 즉시 종료 (손자는 init의 자식이 됨)
}
wait(NULL);  // 자식만 회수, 손자는 init이 회수
```

## execve() 함수

`execve()`는 현재 프로세스의 메모리 이미지를 새로운 프로그램으로 교체하는 시스템 콜입니다.

### 개념

- **정의**: 현재 실행 중인 프로세스의 코드와 데이터를 새로운 프로그램으로 완전히 교체
- **원리**:
  - 프로세스 ID(PID)는 유지되지만 메모리 내용이 새 프로그램으로 교체됨
  - `fork()`와 함께 사용하여 새로운 프로그램 실행
  - 프로세스 생성 없이 프로그램만 교체

### 동작 방식

1. **프로세스 이미지 교체**:

   - 현재 프로세스의 텍스트(코드) 세그먼트를 새 프로그램으로 교체
   - 데이터 세그먼트와 힙을 새 프로그램의 초기값으로 설정
   - 스택을 새로 초기화

2. **프로세스 속성 유지**:

   - 프로세스 ID(PID) 유지
   - 부모 프로세스 ID(PPID) 유지
   - 파일 디스크립터 유지 (close-on-exec 플래그가 없는 경우)
   - 프로세스 그룹 ID, 세션 ID 유지

3. **실행 흐름**:
   ```
   현재 프로세스
     ↓
   execve() 호출
     ↓
   프로그램 파일 로드
     ↓
   메모리 이미지 교체
     ↓
   새 프로그램 실행 시작
   (execve() 이후 코드는 실행되지 않음)
   ```

### 함수 시그니처

```c
#include <unistd.h>

int execve(const char *pathname, char *const argv[], char *const envp[]);
```

- **매개변수**:
  - `pathname`: 실행할 프로그램의 경로
  - `argv`: 프로그램에 전달할 인자 배열 (argv[0]은 보통 프로그램 이름)
  - `envp`: 환경 변수 배열
- **반환값**:
  - 성공 시: 반환하지 않음 (프로세스가 교체되므로)
  - 실패 시: -1 (errno 설정)

### 기본 사용 예시

```c
#include <unistd.h>
#include <stdio.h>

int main() {
    char *argv[] = {"/bin/ls", "-l", NULL};
    char *envp[] = {"PATH=/usr/bin:/bin", "HOME=/home/user", NULL};

    printf("execve() 호출 전\n");

    execve("/bin/ls", argv, envp);

    // 이 코드는 실행되지 않음 (프로세스가 교체되었으므로)
    perror("execve 실패");
    return 1;
}
```

### exec 계열 함수들

exec 계열 함수는 모두 `execve()` 시스템 콜을 기반으로 하는 래퍼 함수들입니다.

| 함수      | 인자 전달 | 경로 검색 | 환경 변수 | 설명                           |
| --------- | -------- | -------- | -------- | ------------------------------ |
| execve()  | 배열 (v) | 전체경로  | 명시 (e) | 시스템 콜 (가장 기본)           |
| execl()   | 리스트 (l)| 전체경로  | 상속     | 가변 인자로 전달                |
| execv()   | 배열 (v) | 전체경로  | 상속     | 배열로 인자 전달                |
| execle()  | 리스트 (l)| 전체경로  | 명시 (e) | 가변 인자 + 환경 변수 명시      |
| execlp()  | 리스트 (l)| PATH (p) | 상속     | PATH에서 검색 + 가변 인자       |
| execvp()  | 배열 (v) | PATH (p) | 상속     | PATH에서 검색 + 배열           |
| execvpe() | 배열 (v) | PATH (p) | 명시 (e) | PATH에서 검색 + 배열 + 환경변수 |

**명명 규칙**:
- **l** (list): 인자를 개별적으로 나열 (`"arg1", "arg2", ..., NULL`)
- **v** (vector): 인자를 배열로 전달 (`char *argv[]`)
- **p** (path): PATH 환경 변수에서 프로그램 검색
- **e** (environment): 환경 변수를 명시적으로 지정

### 사용 예시

```c
// execl - 리스트 형식, 전체 경로
execl("/bin/ls", "ls", "-l", "-a", NULL);

// execlp - 리스트 형식, PATH에서 검색
execlp("ls", "ls", "-l", "-a", NULL);

// execv - 배열 형식, 전체 경로
char *argv[] = {"ls", "-l", "-a", NULL};
execv("/bin/ls", argv);

// execvp - 배열 형식, PATH에서 검색
char *argv[] = {"ls", "-l", "-a", NULL};
execvp("ls", argv);

// execle - 리스트 형식, 환경 변수 명시
char *envp[] = {"PATH=/usr/bin", "HOME=/home/user", NULL};
execle("/bin/ls", "ls", "-l", NULL, envp);

// execve - 배열 형식, 환경 변수 명시 (시스템 콜)
char *argv[] = {"ls", "-l", NULL};
char *envp[] = {"PATH=/usr/bin", NULL};
execve("/bin/ls", argv, envp);
```

### fork()와 execve()의 조합

일반적으로 `fork()`와 `execve()`를 함께 사용하여 새 프로그램을 실행합니다:

```c
pid_t pid = fork();

if (pid == 0) {
    // 자식 프로세스: 새 프로그램 실행
    execve("/bin/ls", argv, envp);
    perror("execve 실패");
    exit(1);
} else if (pid > 0) {
    // 부모 프로세스: 자식 완료 대기
    wait(NULL);
}
```

## ASLR (Address Space Layout Randomization)

### 개념

- **정의**: 프로세스의 메모리 레이아웃을 실행할 때마다 랜덤하게 배치하여 메모리 기반 공격을 어렵게 만드는 보안 기법
- **목적**: 버퍼 오버플로우, 코드 삽입 공격, ROP 등 메모리 주소에 의존하는 공격 방어
- **도입 시기**: 
  - Linux: 커널 2.6.12 (2005년)부터
  - Windows: Vista (2007년)부터
  - macOS: 10.5 Leopard (2007년)부터

### 원리

1. **메모리 주소 랜덤화**:

   - **랜덤화 대상**:
     - 스택 (Stack): 함수 호출 및 지역 변수
     - 힙 (Heap): 동적 메모리 할당
     - 공유 라이브러리 (Shared Libraries): libc, libm 등
     - 실행 코드 (Text Segment): PIE(Position Independent Executable) 사용 시
     - VDSO (Virtual Dynamic Shared Object): 시스템 콜 최적화
   - 프로세스 생성(fork, exec) 시마다 랜덤한 오프셋 적용
   - 엔트로피(무작위성) 수준에 따라 보안 강도 결정

2. **보안 효과**:

   - **버퍼 오버플로우 공격 방어**: 
     - 공격자가 반환 주소(return address)를 예측할 수 없음
     - 스택 카나리(Stack Canary)와 함께 사용하면 더욱 효과적
   - **Return-to-libc 공격 방어**: 
     - 라이브러리 함수 주소를 예측할 수 없음
   - **ROP (Return-Oriented Programming) 공격 완화**: 
     - 가젯(gadget) 주소를 예측하기 어려움
   - **코드 재사용 공격 방어**: 
     - 메모리 정보 유출이 없으면 공격 실행 불가

3. **구현 방식**:
   - **커널 수준**: 
     - `fork()` 및 `execve()` 시 메모리 영역의 기본 주소에 랜덤 오프셋 추가
     - `/dev/urandom`에서 난수 생성
   - **바이너리 수준**: 
     - PIE (Position Independent Executable) 컴파일 필요
     - `-fPIE -pie` 옵션으로 컴파일
   - **라이브러리**: 
     - PIC (Position Independent Code)로 컴파일된 공유 라이브러리

### ASLR 레벨 (Linux)

```bash
# ASLR 상태 확인
cat /proc/sys/kernel/randomize_va_space

# 0: ASLR 비활성화 (보안 위험)
# 1: 보수적 랜덤화 - 스택, 힙, 라이브러리만
# 2: 완전 랜덤화 - 스택, 힙, 라이브러리, VDSO, 데이터 세그먼트

# ASLR 임시 비활성화 (테스트용, 권장하지 않음)
sudo sysctl -w kernel.randomize_va_space=0

# ASLR 활성화
sudo sysctl -w kernel.randomize_va_space=2
```

### 프로세스 메모리 맵 확인

```bash
# 프로세스의 메모리 레이아웃 확인
cat /proc/<PID>/maps

# 예시 출력:
# 5555555550000-555555556000 r--p 00000000 08:01 123456 /bin/cat
# 555555556000-55555555a000 r-xp 00001000 08:01 123456 /bin/cat
# 7ffff7dd0000-7ffff7df0000 r--p 00000000 08:01 234567 /lib/libc.so.6
# 7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0      [stack]

# 같은 프로그램을 여러 번 실행하면 주소가 다름
./my_program &
cat /proc/$!/maps | grep stack

./my_program &
cat /proc/$!/maps | grep stack
```

### PIE (Position Independent Executable)

```bash
# PIE로 컴파일 (ASLR 완전 적용)
gcc -fPIE -pie -o program program.c

# PIE 없이 컴파일 (코드 영역은 고정 주소)
gcc -no-pie -o program program.c

# 바이너리가 PIE인지 확인
file program
# 출력: ELF 64-bit LSB pie executable ... (PIE)
# 또는: ELF 64-bit LSB executable ... (not PIE)

readelf -h program | grep Type
# 출력: Type: DYN (Position Independent Executable)
# 또는: Type: EXEC (일반 실행 파일)
```

### ASLR 실험 코드

```c
// aslr_test.c - ASLR 확인 프로그램
#include <stdio.h>
#include <stdlib.h>

int global_var = 100;           // 데이터 세그먼트
int uninitialized_var;          // BSS 세그먼트

void print_addresses() {
    int stack_var = 42;         // 스택
    int *heap_var = malloc(sizeof(int));  // 힙
    
    printf("코드 영역 (함수):    %p\n", (void*)print_addresses);
    printf("전역 변수 (데이터):  %p\n", (void*)&global_var);
    printf("BSS 세그먼트:       %p\n", (void*)&uninitialized_var);
    printf("스택:              %p\n", (void*)&stack_var);
    printf("힙:                %p\n", (void*)heap_var);
    printf("라이브러리 (printf): %p\n", (void*)printf);
    
    free(heap_var);
}

int main() {
    printf("PID: %d\n", getpid());
    print_addresses();
    return 0;
}
```

```bash
# 컴파일 및 실행 (PIE 활성화)
gcc -fPIE -pie -o aslr_test aslr_test.c

# 여러 번 실행하여 주소 변화 확인
./aslr_test
./aslr_test
./aslr_test
# 매번 다른 주소가 출력됨
```

### ASLR의 한계

1. **정보 유출 취약점**: 
   - 메모리 주소가 유출되면 ASLR 무력화
   - Format String Bug, Use-After-Free 등으로 주소 정보 유출 가능

2. **브루트 포스 공격**: 
   - 32비트 시스템은 엔트로피가 낮아 반복 공격 가능
   - 64비트 시스템은 주소 공간이 넓어 실질적으로 안전

3. **부분 오버라이트**: 
   - 주소의 일부만 변경하여 ASLR 우회 가능

4. **JIT 스프레이**: 
   - JavaScript JIT 컴파일러 등을 이용한 공격

### 추가 보안 기법

ASLR과 함께 사용하는 보안 기법들:

- **DEP/NX (Data Execution Prevention / No-eXecute)**: 
  - 데이터 영역(스택, 힙)에서 코드 실행 방지
  - 컴파일: `-z execstack` (비활성화), `-z noexecstack` (활성화)

- **Stack Canary**: 
  - 스택 버퍼 오버플로우 탐지
  - 컴파일: `-fstack-protector` 또는 `-fstack-protector-strong`

- **RELRO (Relocation Read-Only)**: 
  - GOT(Global Offset Table) 보호
  - 컴파일: `-Wl,-z,relro,-z,now` (Full RELRO)

```bash
# 모든 보안 기법 활성화 컴파일
gcc -fPIE -pie \
    -fstack-protector-strong \
    -D_FORTIFY_SOURCE=2 \
    -Wl,-z,relro,-z,now \
    -Wl,-z,noexecstack \
    -o secure_program program.c
```

## 프로세스의 부모-자식 관계

### 개념

- **부모 프로세스 (Parent Process)**: 다른 프로세스를 생성한 프로세스
- **자식 프로세스 (Child Process)**: `fork()`에 의해 생성된 프로세스
- **프로세스 트리**: 모든 프로세스는 부모-자식 관계로 트리 구조를 형성

### 관계의 특징

1. **PID와 PPID**:

   - 각 프로세스는 고유한 PID (Process ID)를 가짐
   - PPID (Parent Process ID)로 부모 프로세스를 식별
   - `getpid()`: 자신의 PID 반환
   - `getppid()`: 부모의 PID 반환

2. **리소스 상속**:

   - 파일 디스크립터 상속
   - 환경 변수 상속
   - 작업 디렉토리 상속
   - 사용자 ID, 그룹 ID 상속

3. **프로세스 계층 구조**:
   ```
   init (PID 1)
   ├── systemd / launchd
   │   ├── sshd
   │   │   └── bash
   │   │       └── ls
   │   └── httpd
   │       ├── worker 1
   │       └── worker 2
   ```

### 프로세스 트리 확인

```bash
# 프로세스 트리 확인
pstree
pstree -p  # PID 포함

# 특정 프로세스의 부모 확인
ps -o pid,ppid,cmd -p <PID>
```

## 프로세스 상태

프로세스는 실행 중 다양한 상태를 거치며 전환됩니다.

### 주요 프로세스 상태

1. **Running (실행 중, R)**:

   - CPU에서 실행 중이거나 실행 대기 중
   - 실행 가능한 상태

2. **Sleeping (대기 중, S)**:

   - I/O 작업이나 이벤트를 기다리는 상태
   - 인터럽트 가능한 대기 (interruptible sleep)

3. **Uninterruptible Sleep (D)**:

   - 디스크 I/O 등 중요한 작업을 기다리는 상태
   - 시그널로 깨울 수 없음

4. **Stopped (T)**:

   - 시그널(SIGSTOP, SIGTSTP)에 의해 일시 정지된 상태
   - SIGCONT 시그널로 재개 가능

5. **Zombie (Z)**:
   - 프로세스가 종료되었지만 부모가 종료 상태를 회수하지 않은 상태
   - 프로세스 테이블에만 남아있음

### 상태 전환

```
생성 (fork)
  ↓
Ready (준비)
  ↓
Running (실행)
  ↓
Sleeping (대기) ←→ Running
  ↓
Terminated (종료)
  ↓
Zombie (좀비) → 회수 (wait)
```

### 프로세스 상태 확인

```bash
# 프로세스 상태 확인
ps aux
ps -eo pid,state,cmd

# 실시간 모니터링
top
htop
```

## 프로세스 종료

프로세스가 정상적으로 또는 비정상적으로 종료되는 과정입니다.

### 종료 방법

1. **정상 종료**:

   - `exit()` 함수 호출
   - `main()` 함수에서 `return`
   - 프로그램이 정상적으로 완료

2. **시그널에 의한 종료**:

   - `SIGTERM`: 정상 종료 요청
   - `SIGKILL`: 강제 종료 (처리 불가)
   - `SIGINT`: 인터럽트 (Ctrl+C)

3. **에러로 인한 종료**:
   - 세그먼테이션 폴트 (SIGSEGV)
   - 부동소수점 예외 (SIGFPE)
   - 잘못된 명령어 (SIGILL)

### exit() 함수

```c
#include <stdlib.h>

void exit(int status);
```

- **기능**: 프로세스를 정상적으로 종료
- **status**: 종료 상태 코드 (0: 성공, 그 외: 실패)
- **동작**:
  1. 종료 핸들러 실행
  2. 버퍼 플러시
  3. 열린 파일 닫기
  4. 부모에게 종료 상태 전달

### 종료 상태 확인

```bash
# 마지막 명령의 종료 상태 확인
echo $?

# 0: 성공, 그 외: 실패
```

## 좀비 프로세스와 고아 프로세스

### 좀비 프로세스 (Zombie Process)

- **개념**: 종료되었지만 부모 프로세스가 종료 상태를 회수하지 않은 프로세스
- **원인**:
  - 자식 프로세스가 종료되었지만 부모가 `wait()` 또는 `waitpid()`를 호출하지 않음
  - 프로세스 테이블에만 남아있고 실제 메모리는 해제됨
- **문제점**:
  - 프로세스 테이블 슬롯을 차지
  - 많은 좀비 프로세스가 있으면 새 프로세스 생성 불가
- **해결 방법**:
  ```c
  // 부모 프로세스에서
  wait(NULL);  // 자식 프로세스 종료 대기
  // 또는
  waitpid(pid, NULL, 0);
  ```
- **확인 방법**:
  ```bash
  ps aux | grep Z
  ```

### 고아 프로세스 (Orphan Process)

- **개념**: 부모 프로세스가 먼저 종료되어 부모가 없는 프로세스
- **처리 방식**:
  - 고아 프로세스는 init 프로세스(PID 1)의 자식이 됨
  - init 프로세스가 자동으로 `wait()`를 호출하여 좀비가 되지 않도록 함
- **예시**:

  ```c
  pid_t pid = fork();

  if (pid == 0) {
      // 자식 프로세스
      sleep(10);  // 부모가 먼저 종료되면 고아가 됨
      // 이제 부모는 init (PID 1)
  } else {
      // 부모 프로세스
      exit(0);  // 자식을 기다리지 않고 종료
  }
  ```

## 시그널 (Signal)

시그널은 프로세스 간 통신과 프로세스 제어를 위한 메커니즘입니다.

### 개념

- **정의**: 프로세스에게 특정 이벤트가 발생했음을 알리는 비동기 메커니즘
- **원리**: 커널이 프로세스에게 시그널을 전달하고, 프로세스는 시그널 핸들러로 처리

### 주요 시그널

| 시그널  | 번호 | 의미                    | 기본 동작         |
| ------- | ---- | ----------------------- | ----------------- |
| SIGHUP  | 1    | 터미널 연결 끊김        | 종료              |
| SIGINT  | 2    | 인터럽트 (Ctrl+C)       | 종료              |
| SIGQUIT | 3    | 종료 (Ctrl+\)           | 코어 덤프 후 종료 |
| SIGKILL | 9    | 강제 종료               | 종료 (처리 불가)  |
| SIGTERM | 15   | 종료 요청               | 종료              |
| SIGSTOP | 19   | 일시 정지               | 정지 (처리 불가)  |
| SIGCONT | 18   | 재개                    | 계속 실행         |
| SIGCHLD | 17   | 자식 프로세스 상태 변경 | 무시              |

### 시그널 전송

```c
#include <signal.h>

int kill(pid_t pid, int sig);
```

- **pid**: 시그널을 보낼 프로세스 ID
  - `> 0`: 특정 프로세스
  - `0`: 같은 프로세스 그룹
  - `-1`: 모든 프로세스 (권한 필요)
- **sig**: 전송할 시그널 번호

### 시그널 핸들러 등록

```c
#include <signal.h>

void signal_handler(int sig) {
    printf("시그널 %d 수신\n", sig);
}

int main() {
    signal(SIGINT, signal_handler);  // SIGINT 핸들러 등록
    // 또는
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigaction(SIGINT, &sa, NULL);

    while(1) {
        pause();  // 시그널 대기
    }
}
```

### 시그널 블로킹

```c
sigset_t set;
sigemptyset(&set);
sigaddset(&set, SIGINT);
sigprocmask(SIG_BLOCK, &set, NULL);  // SIGINT 블로킹
```

## 셸 작업 관리 구현

셸(Shell)은 백그라운드 작업과 포그라운드 작업을 관리합니다.

### 포그라운드 작업 (Foreground Job)

- **개념**: 사용자 입력을 받고 터미널 출력을 표시하는 작업
- **특징**:
  - 터미널을 독점
  - Ctrl+C로 중단 가능
  - 작업이 완료될 때까지 다음 명령 입력 불가

### 백그라운드 작업 (Background Job)

- **개념**: 터미널과 독립적으로 실행되는 작업
- **실행 방법**:
  ```bash
  command &  # 명령어 끝에 & 추가
  ```
- **특징**:
  - 터미널을 차단하지 않음
  - 즉시 다음 명령 입력 가능
  - 작업 ID(Job ID)로 관리

### 작업 관리 명령어

```bash
# 백그라운드로 실행
sleep 100 &

# 실행 중인 작업 확인
jobs

# 작업을 포그라운드로 가져오기
fg %1  # 작업 1번을 포그라운드로

# 작업을 백그라운드로 보내기
bg %1  # 작업 1번을 백그라운드로

# 작업 종료
kill %1  # 작업 1번 종료
```

### 구현 원리

1. **프로세스 그룹**:

   - 셸이 생성한 작업은 같은 프로세스 그룹에 속함
   - 프로세스 그룹에 시그널을 보내면 모든 프로세스에 전달

2. **터미널 제어**:

   - 포그라운드 작업: 터미널의 제어 터미널(controlling terminal)이 됨
   - 백그라운드 작업: 제어 터미널이 없음

3. **시그널 처리**:
   - Ctrl+C: SIGINT를 포그라운드 프로세스 그룹에 전송
   - Ctrl+Z: SIGTSTP를 포그라운드 프로세스 그룹에 전송

## 세션 (Session)

### 개념

- **정의**: 하나 이상의 프로세스 그룹을 포함하는 논리적 단위
- **목적**: 로그인 세션과 터미널 세션을 관리

### 세션의 특징

1. **세션 리더 (Session Leader)**:

   - 세션을 생성한 프로세스
   - 세션 ID(SID)는 세션 리더의 PID와 같음
   - 일반적으로 셸 프로세스

2. **제어 터미널 (Controlling Terminal)**:

   - 세션에 연결된 터미널
   - 한 세션은 최대 하나의 제어 터미널을 가짐
   - 포그라운드 프로세스 그룹만 제어 터미널과 상호작용

3. **세션 생성**:
   ```c
   pid_t setsid(void);
   ```
   - 새로운 세션을 생성하고 호출 프로세스를 세션 리더로 만듦
   - 제어 터미널과의 연결을 끊음

### 세션 확인

```bash
# 프로세스의 세션 ID 확인
ps -eo pid,sid,tty,cmd

# 세션 리더 확인
ps -p $(ps -o sid= -p <PID>)
```

## 프로세스 그룹 (Process Group)

### 개념

- **정의**: 관련된 프로세스들의 집합
- **목적**: 시그널을 그룹 단위로 전송하고 관리

### 프로세스 그룹의 특징

1. **프로세스 그룹 ID (PGID)**:

   - 각 프로세스 그룹은 고유한 PGID를 가짐
   - 프로세스 그룹 리더의 PID가 PGID가 됨

2. **그룹 리더 (Group Leader)**:

   - 프로세스 그룹을 생성한 프로세스
   - 일반적으로 셸이 생성한 작업의 첫 번째 프로세스

3. **시그널 전송**:
   - 프로세스 그룹에 시그널을 보내면 그룹의 모든 프로세스에 전달
   - 예: `kill -SIGINT -<PGID>` (음수는 프로세스 그룹을 의미)

### 프로세스 그룹 생성

```c
#include <unistd.h>

pid_t setpgid(pid_t pid, pid_t pgid);
```

- **pid**: 프로세스 ID (0이면 현재 프로세스)
- **pgid**: 프로세스 그룹 ID (0이면 pid를 PGID로 사용)

### 프로세스 그룹 확인

```bash
# 프로세스 그룹 정보 확인
ps -eo pid,pgid,sid,tty,cmd

# 특정 프로세스 그룹의 모든 프로세스
ps -g <PGID>
```

## 데몬 (Daemon)

### 개념

- **정의**: 백그라운드에서 지속적으로 실행되는 시스템 서비스 프로세스
- **특징**: 사용자와 직접 상호작용하지 않고 시스템 서비스를 제공

### 데몬의 특징

1. **독립 실행**:

   - 부모 프로세스와 분리
   - 제어 터미널이 없음
   - init 프로세스의 자식이 됨

2. **백그라운드 실행**:

   - 터미널과 독립적으로 실행
   - 사용자 로그아웃 후에도 계속 실행

3. **시스템 서비스**:
   - 웹 서버, 데이터베이스 서버, 로그 데몬 등
   - 시스템 부팅 시 자동 시작

### 데몬 생성 과정

```c
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>

int main() {
    pid_t pid;

    // 1. fork()로 자식 프로세스 생성
    pid = fork();
    if (pid < 0) {
        exit(1);
    }

    // 2. 부모 프로세스 종료 (자식이 init의 자식이 됨)
    if (pid > 0) {
        exit(0);
    }

    // 3. 새로운 세션 생성 (제어 터미널 분리)
    if (setsid() < 0) {
        exit(1);
    }

    // 4. 다시 fork() (세션 리더가 되지 않도록)
    pid = fork();
    if (pid < 0) {
        exit(1);
    }
    if (pid > 0) {
        exit(0);
    }

    // 5. 작업 디렉토리 변경
    chdir("/");

    // 6. 파일 모드 마스크 설정
    umask(0);

    // 7. 표준 입출력 닫기
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);

    // 8. 데몬 작업 수행
    while (1) {
        // 데몬 로직
        sleep(1);
    }

    return 0;
}
```

### 데몬 확인

```bash
# 실행 중인 데몬 확인
ps aux | grep -E '\[.*\]$'  # 커널 스레드는 [ ]로 표시

# 시스템 서비스 확인 (systemd)
systemctl list-units --type=service

# 실행 중인 데몬 프로세스
ps -eo pid,ppid,sid,tty,cmd | grep -v '?' | grep -v 'tty'
```

### 주요 데몬 예시

- **sshd**: SSH 서버 데몬
- **httpd / nginx**: 웹 서버 데몬
- **mysqld**: MySQL 데이터베이스 데몬
- **syslogd**: 시스템 로그 데몬
- **cron**: 스케줄 작업 데몬
